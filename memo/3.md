# アプリ

閲覧系App|概要
---------|----
viewer|原稿も入力データである（gzip圧縮をBase64URL化しURLパラメータとして受け渡す）
reader|原稿はローカルDBにあり、栞(開始位置)など読書に最低限必要な機能がある
referer|原稿はデプロイ済みでURLによる栞(開始位置)やdiff表示など外部から参照することに特化する

生成系App|概要
---------|----
generator|原稿からTextBlock,HTMLElement,ページ分割データを生成する
maker|原稿からHTML,CSS,JS,PDFファイルを生成する

制作系App|概要
---------|----
writer|原稿ファイルを作成する（）
editor|原稿ファイルを編集する（デプロイ後に部分修正し版や修正履歴をメタデータとして管理し原稿に追記する）

Web系App|概要
--------|----
deployer|HTTPSサーバに原稿やRefererなどをアップロードする（）

主体|抽象|具象
----|----|----
読者|view|read
筆者|edit|write
全員|make|generate
筆者|regist,record|SQLite3DB（一人の著者単位でDB化する。shareする著者情報、作品の要約情報、作品全文、作品diffの4テーブル）
筆者|upload|特定のWEB上にデータをアップロードする（自分のGitHubに全データをUPし、共有WEB上に要約情報のみをUPする）
読者|download|特定のWEB上からデータをダウンロードする（共有WEBから要約情報のみをDLし、筆者のGitHubから全データをDLする）
全員|share|title,catch,obi,url,id,chars,date,state(完結／未完),category,tag,self-rating,author(.name,.url,.id)
開発|api|getHTML, getJavel, getExample

　読者は原稿を入力して読書に最適な画面を表示する(view)。但し原稿をそのまま読みたい時もある(read)。また、原稿の間違いを指摘(point)したり、感想を書いたり(opinion,comment)評価したい(Evaluate)こともある。

　読者

# 実行形式・プラットフォーム

* CLI
* ネイティブGUIアプリ
* WebAPI
* ブラウザ(`file://`)
* ブラウザ(`https://`)
* ブラウザ(PWA)

環境|CUI|GUI
----|---|---
ネイティブOS|CLI|ネイティブGUIアプリ(GUIライブラリには複数の選択肢がある)
WebKit使用|-|ネイティブGUIアプリ(ブラウザエンジンには複数の選択肢がある)
ブラウザ拡張|ブックマークレット|ブラウザ拡張GUI
ブラウザ|WebAPI|`file://`, `https://`, PWA

　できればCLIやWebAPIでもページ分割されたHTMLを取得したい。しかし座標計算はdocumentに追加し表示することが必要なため、GUIを持たないCLIやWebAPIではページ分割は不可能。できることはJavelテキストをHTMLテキストに変換する所まで。論理的にはテキスト、フォント、画面サイズから計算可能なはずだが、JavaScriptではDOMに追加し表示しないと計算できない仕様である。OSネイティブな低レベルAPIが使えれば計算可能だと思われる。

　アプリ形態は三次元の指標で評価する。

          要約/束縛/簡易
                |     広域
                |　／
手動            |／          自動
面倒　----------+----------　安楽
低速         ／ |            高速
           ／   |
       狭域     |
          詳細/自由/難解

次元|概要
----|----
要約／詳細|シンプル＆少機能 vs 煩雑＆多機能
手動／自動|手入力必須で制御可 vs 自動化され制御不能
狭域／広域|ローカル保存のみで社会的安全 vs ネット通信可で社会的危険

　要約を手動で狭域に実行するのが安全かつ効率的。特に最初は簡単に使えるようにすべき。慣れてきたら複雑化して詳細に操りつつ自動化して最高効率化できるほうが好ましい。また、これを広域に与えることができる選択肢も欲しい。

　これらを単一のアプリで実現するのは困難であり非効率的であり危険性を孕む。まずはブラウザによりクロスプラットフォーム性を確保して多くの環境で動作できるようにする。そして要約・手動・狭域のみの安全かつ簡易な方法だけを提供する。本当は自動化まではカバーしたかったのだが、ブラウザの仕様上ページ計算は自動化できないため断念する。a

　CLI/WebAPI化できるのはJavelテキストをHTMLテキストに変換する部分だけだ。これなら描画時の座標計算が不要なので計算可能である。但しJavelの本懐であるページ分割ができないため、本末転倒だ。それでもJavelテキストのパースだけは自動化できるため、その用途に限った有用性は一応あるはずだ。

ISO 25010 のソフトウエア品質特性の紹介
https://qiita.com/mmake/items/ca97c616af0762a5164d

* 利用時の品質
    * 有効性（設定された目標や要件をどれだけ効果的に達成できたか）
    * 効率性（リソースをどれだけ効率的に利用できるか）
    * 満足性（ユーザがどれだけ満足しているか）
        * 実用性（ユーザにとって実用的であり満足できるか）
        * 信用性（ユーザに信頼感を与え、期待通りに動作するか）
        * 快感性（ユーザに楽しさや満足感をもたらすか）
        * 快適性（ユーザに快適な体験をもたらすか）
    * リスク回避性（ソフトウェアが予測可能で潜在的なリスクを最小限に抑えるか）
        * 経済リスク緩和性（ソフトウェアの利用がビジネスや経済においてリスクを軽減するか）
        * 健康・安全リスク緩和性（ソフトウェアを使用することで生じる健康や安全に関するリスクを軽減するか）
        * 環境リスク緩和性（ソフトウェアが環境に対して与えるリスクを軽減するか）
    * 利用状況網羅性（異なる環境や状況にどれだけ対応できるか）
        * 利用状況完全性（異なる状況や文脈でどれだけ対応できるか）
        * 柔軟性（柔軟に拡張や変更ができるか）

* 製品の品質
    * 機能適合性（ユーザのニーズや期待にどれだけ適しているか）
        * 機能完全性（必要な機能を十分に提供しているか）
        * 機能正確性（期待通りに動作するか）
        * 機能適切性（ニーズに適しているか）
    * 性能効率性（リソースの使用を最適化し高性能を維持できるか）
        * 時間効率性（どれだけ速く実行できるか）
        * 資源効率性（CPUやメモリを効果的に利用しているか）
        * 容量満足性（処理できるデータやユーザの数量は十分か）
    * 互換性（他のシステムやプラットフォームとどれだけ連携できるか）
        * 共存性（他のソフトウェアと共存し、干渉なく使用できるか）
        * 互換運用性（他のシステムやプラットフォームと効果的に連携できるか）
    * 使用性（ユーザにとってどれだけ使いやすいか）
        * 適切度認識性（ユーザの期待に適切に答え、理解しやすいか）
        * 習得性（はじめて使うユーザがどれだけ早く理解して使いこなせるか）
        * 運用操作性（正確な操作を提供し、ユーザが簡単に操作できるか）
        * ユーザエラー防止性（ユーザの誤操作を防ぎ、誤操作しても影響を最小限に抑えるか）
        * ユーザインタフェース快美性（UIが美的で魅力的か）
        * アクセシビリティ（身障者を含む全ての人が利用しやすいか）
    * 信頼性（安定して動作し、障害やエラーが発生しづらいこと）
        * 成熟性（どれだけ安定しており、問題なく動作するか）
        * 可用性（必要な時に利用可能か）
        * 障害許容性（耐故障性）（障害やエラーに対してどれだけ耐性があるか）
        * 回復性（障害から迅速に回復できるか）
    * セキュリティ（データや利用者の情報を保護し、権限のないアクセスから守ること）
        * 気密性（データや情報をどれだけ気密に保護できるか）
        * インテグリティ（保全性。データや情報を正確に保ち、改竄を防げるか）
        * 否認防止性（ユーザが行ったアクションや取引を否認できぬよう保護するか）
        * 責任追跡性（誰が何を行ったかを追跡できるか）
        * 真正性（ソフトウェアが本物で信頼性があり、名前の盗用を防げるか）
    * 保守性（変更や修正を容易に受け入れ、保守作業がスムーズに行えること）
        * モジュール性（構成要素が独立しており、変更や修正が容易か）
        * 再利用性（他のシステムで再利用できるか）
        * 解析性（障害の監視やログ取得が容易か）
        * 修正性（変更や修正は容易か）
        * 試験性（試験が容易に行えるか）
    * 移植性（異なる環境やプラットフォームへ簡単に移植できること）
        * 適応性（異なる環境やプラットフォームに適応できるか）
        * 設置性（インストールが容易か）
        * 置換性（新しいバージョンに置き換えられるか）

# Javelにおける重視すべき品質評価

## 優先順位

1. 有効性・満足性・機能適合性・使用性
2. 利用状況網羅性・移植性・互換性
3. 信頼性・セキュリティ・リスク回避性
4. 効率性・性能効率性
5. 保守性

　1〜3までは必須、4〜5はオプション。

　1の有効性がなければ全て無駄である。ユーザに売り込んだ目標や要件の達成は最優先だ。それを証明するために満足性・機能適合性・使用性の面から詳細に評価する。

　2の利用状況網羅性がなければ利用不可能な状態に陥る。特に昨今は実行環境が多様化しており、動作保証が難しい。また、ニーズの多様化もしていることから、1の有効性を担保するための根拠として移植性・互換性が必要である。

　3の信頼性は絶対に要る。いざ使用したら動作しない、エラーだらけ。それでは役に立たず1の有効性が示せない。

　4の効率性は、できれば実現したい。少なくとも4が証明されなければ1の有効性にケチがつく。1を否定させぬための裏付けとして示したい。

　5の保守性は、できれば実現したい。もし何か問題があっても簡単にコード修正できれば、対応は容易である。全ての問題に簡単に対応できれば、最悪の事態に陥っても安心だ。自力でどうにかできる。それも効率的に。それが示せれば安心してアプリを利用できる。

## 概要

　Javelの目標・要件は「本のように読めること」だ。これが一番の目的であり目標である。すなわち既存WEBのスクロールでは文字が見切れる所を、ページ分割によって文字が見きれぬようにする。ページ単位で必ず文字全体が画面内に収まるようにする。文字が見切れず、開始位置が定まるため、余計な判断をせずシンプルに読める。

　問題はPCやスマホなどデバイスにより画面サイズが大きく異なることだ。これによりページ分割結果が全く変わるため、動的にページ分割する必要がある。しかもその計算は原稿のテキスト量が多いほど長大になってしまう。パフォーマンス問題が起きる。もし高速処理できる環境なら良いが、今回は低速環境であるブラウザが対象だ。

　二番目は利用状況網羅性を重視する。すなわち、いつでも誰でも何処でもいくらでも永久に無料で使用可能であることを重視する。ユーザの経済状況やネット接続状況、利用可能なデバイスやOS、社会が個人情報の提供を共用する中でもプライバシーを守れること。経済社会の中でも利益追求せずに利用できること。利益追求によるメタクソ化を完全回避してユーザの利益を最大化すること。身体障害があっても利用可能であること。あらゆる環境・状況に対して権威・社会・他者・自己能力に支配されず、全てを自分の好みや都合に最適化できるようにすること。これを実現するために、開発者である私は一切利権を主張しないオープンソースでアプリを提供する。なるだけアクセシビリティに配慮する。利用できないアプリには価値などないのだから。

　ユーザの利益を最大化すること。開発者や運用者の利益を追求するためにユーザの利益を犠牲にしないこと。利用者・開発者・運用者を区別せず、全てのフェーズにおいて「創作活動それ自体を楽しむこと」という目標を掲げる。それはつまり「創作的でない形式的なつまらない部分を修正・自動化すること」を意味する。このうち修正する部分は「本のように読めること」だ。既存のWEBにおける読書体験に対する不満を修正したい。これに対して「自動化」の優先度は低い。どこでも動作する移植性のほうが優先すべきだ。自動化は効率化であり、効率的であることは期待通りに動作することが実現したあとで気にすることだから。

　利益追求でなく創作追求を実現する。開発者・運用者より利用者の利益を優先する。但し利用者の利益を効率的に開発するためには保守性まで考慮せねばならない。保守性の優先順位は最低である。これは無視していい理由ではなく、開発者・運用者より利用者の利益を優先するという意味だ。むしろ開発者は利用者の目的を実現することが目的なので、利用者の利益が最大化することで開発者の利益が最大化すると言える。開発・運用は利用者が利益を享受する手段に過ぎない。

　私達は創作を楽しむためにツールを開発・運用するという手段を講じるのだ。これは他人にやってもらうのではなく、自分でやることを意味する。それ自体をも創作活動として楽しむことが目標なのである。故にそれが可能なようにオープンソースであることが最低条件であり、それを実現するためには保守性すらも担保すべきである。

　営利目的との決別。営利目的・利益追求すると製品・サービスの品質が時間経過とともに劣化していくenshittification（エシット化、メタクソ化）が知られている。目的は運営者が利用者から金銭を効率的に徴収することであるため、品質向上させるコストを削減させる必要があり、故にユーザの利益は時間とともに失われる。他人に自分の利益創造を委ねれば、他人に搾取される結果を招く。依存せねば生きられぬ生物における道理だ。

　ユーザの利益を最大化するためには営利目的を排除すべきである。これにてユーザの利用価値を損ねるサ終、改悪が起きメタクソ化することを防ぐ。
　ユーザを管理し利権を生みだすべくアカウント登録や規約遵守などを強いる既存の小説投稿サイトでもなく。
　囲い込み戦略のため特定のデバイスやOSを要するスマホアプリやネイティブアプリでもなく。
　Javelは全OSに存在するブラウザ上から動作し、全ユーザが自由に利用でき、かつコードを改変でき自分に最適化できるオープンソースという利用状況網羅性・移植性・互換性を重視する。それが一番目の有効性を担保する。

　三番目は、二番目の利用状況網羅性を実現するための移植性・互換性である。PCやスマホなどデバイスが変わっても同じような読書体験ができること。OSやブラウザ、バージョンが違っても機能すること。つまりクロスプラットフォームであり、レスポンシブであり、プログレッシブであること。

### 1. 有効性・満足性・機能適合性・使用性

* 本のように読めること
    * ページを捲る（文字が見切れず視線の位置と導線が確定できるため負担が少ない）
* 創作活動を楽しめること
    * 読書を楽しめること（＋感想、意見、評価）
    * 執筆を楽しめること（＋調査、学習、成果の定量化・俯瞰、思考、創意工夫・試行錯誤、創作論、自動化、実装）

### 2. 利用状況網羅性・移植性・互換性

* 本のように読めること
    * 入力形式
        * テキスト入力だけで
        * ファイルを入力しただけで
        * URLを入力しただけで
    * 入力データ形式
        * UTF-8テキスト（Shift-JIS、EUC等他の形式は無効。テキストはUTF8に限定することで汎用性を高める風潮になっている。特にWEBはその傾向が強い。よってUTF8だけで良い）
    * テキスト形式
        * 日本語小説をHTMLに変換する簡易書式
            * 青空文庫書式
            * カクヨム
            * 小説家になろう
            * アルファポリス
            * その他、小説投稿サイト独自の形式に相互変換できること
* 機能拡張性
    * パース構文を自分で拡張できること
    * ネットから作品の投稿・参照ができること
        * WebAPIを用いて作品の投稿・取得ができること
            * 但し既存の小説投稿サイトは基本的にWebAPIがなく、あっても作品の取得だけ
            * Javelにおいてはどうにかしてサーバをもたずに作品の投稿・取得を実現したい
                * BlueSkyのベースであるAT protocolが使えそう

　できれば次のような機能も欲しい。

* 本のように読めること
    * アプリを起動しただけで
        * 他人が執筆した作品を
            * ネットから自動で収集して通知する
                * 著者は自分のGitHubリポジトリに作品全文を示したJavelテキストファイルをアップロードする
                * 上記が済んだら、Javel開発者が用意した共有用GitHubリポジトリに対して上記の要約情報をアップロードすべくリクエストする
                    * 

### 3. 信頼性・セキュリティ・リスク回避性

* 期待通りに動作し、余計な問題が起きないこと

### 4. 効率性・性能効率性

* アプリを使わず人力で実行する時と比べて効率的に創作を楽しめること
* アプリを使わず人力で実行する時と比べて効率的に成果物を出力できること

### 5. 保守性

* アプリのコードを修正することが可能であること
* アプリのコードを修正することが容易であること
* アプリのコードを流用することが容易であること

## 1. 移植性

## 2. 互換性

## 3. 利用状況網羅性

## 4. 有効性
## 5. 満足性


## 
